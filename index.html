<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DWT Watermarking Demo</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="min-h-screen flex flex-col items-center gap-6 p-6 bg-gray-50 text-sm">
  <h1 class="text-2xl font-semibold">DWT Watermarking Demo</h1>

  <!-- Controls -->
  <div class="flex flex-wrap gap-3 justify-center">
    <input id="imgInput" type="file" accept="image/*" class="hidden" />
    <button id="btnAdd" class="px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700">Add Image</button>

    <input id="wmImgInput" type="file" accept="image/*" class="hidden" />
    <button id="btnSelWM" class="px-4 py-2 rounded bg-blue-600 text-white hover:bg-blue-700">Select Watermark Image</button>

    <input id="wmText" type="text" placeholder="Watermark Text (optional)" class="px-2 py-2 border rounded" />

    <button id="btnEmbed" class="px-4 py-2 rounded bg-green-600 text-white hover:bg-green-700">Embedding</button>
    <button id="btnDownload" class="px-4 py-2 rounded bg-indigo-600 text-white hover:bg-indigo-700">Download Embedded</button>
    <button id="btnRetrieve" class="px-4 py-2 rounded bg-purple-600 text-white hover:bg-purple-700">Retrieval</button>
  </div>

  <!-- Frames -->
  <div class="grid md:grid-cols-2 gap-6 w-full max-w-4xl">
    <div class="flex flex-col items-center gap-2">
      <p class="font-medium">Original / Embedded Image</p>
      <canvas id="origCan" width="256" height="256" class="border shadow rounded"></canvas>
    </div>
    <div class="flex flex-col items-center gap-2">
      <p class="font-medium">Watermark / Retrieval Result</p>
      <canvas id="wmCan" width="128" height="128" class="border shadow rounded"></canvas>
    </div>
  </div>

  <script>
  let imgW = 0, imgH = 0;
  let origGray = null;
  let origRGB = null;
  let wmBits = null;
  let embeddedGray = null;

  const origCan = document.getElementById('origCan');
  const wmCan = document.getElementById('wmCan');
  const ctxO = origCan.getContext('2d');
  const ctxW = wmCan.getContext('2d');

  function imageToGray(img, canvas) {
    const MAX = 512;
    const scale = Math.min(1, MAX / Math.max(img.width, img.height));
    const w = (Math.floor(img.width * scale)) & ~1;
    const h = (Math.floor(img.height * scale)) & ~1;
    canvas.width = w; canvas.height = h;
    const c = canvas.getContext('2d');
    c.drawImage(img, 0, 0, w, h);
    const rgba = c.getImageData(0, 0, w, h).data;
    const gray = new Float32Array(w * h);
    for (let i = 0; i < gray.length; i++) {
      const r = rgba[i * 4], g = rgba[i * 4 + 1], b = rgba[i * 4 + 2];
      gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;
    }
    return gray;
  }

  function grayToCanvas(gray, w, h, canvas) {
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    const img = ctx.createImageData(w, h);
    for (let i = 0; i < gray.length; i++) {
      const v = Math.max(0, Math.min(255, gray[i]));
      img.data[i * 4] = img.data[i * 4 + 1] = img.data[i * 4 + 2] = v;
      img.data[i * 4 + 3] = 255;
    }
    ctx.putImageData(img, 0, 0);
  }

  function textToBits(txt) {
    return Uint8Array.from(txt.split('').flatMap(ch => ch.charCodeAt(0).toString(2).padStart(8, '0').split('').map(Number)));
  }

  function dwt2D(data, h, w) {
    const halfH = h >> 1, halfW = w >> 1;
    const tmpA = new Float32Array(h * halfW), tmpD = new Float32Array(h * halfW);
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < halfW; x++) {
        const a = data[y * w + (x << 1)], b = data[y * w + (x << 1) + 1];
        tmpA[y * halfW + x] = (a + b) / 2;
        tmpD[y * halfW + x] = (a - b) / 2;
      }
    }
    const LL = new Float32Array(halfH * halfW);
    const LH = new Float32Array(halfH * halfW);
    const HL = new Float32Array(halfH * halfW);
    const HH = new Float32Array(halfH * halfW);
    for (let y = 0; y < halfH; y++) {
      for (let x = 0; x < halfW; x++) {
        const a1 = tmpA[(y << 1) * halfW + x], a2 = tmpA[((y << 1) + 1) * halfW + x];
        const d1 = tmpD[(y << 1) * halfW + x], d2 = tmpD[((y << 1) + 1) * halfW + x];
        const idx = y * halfW + x;
        LL[idx] = (a1 + a2) / 2;
        LH[idx] = (a1 - a2) / 2;
        HL[idx] = (d1 + d2) / 2;
        HH[idx] = (d1 - d2) / 2;
      }
    }
    return { LL, LH, HL, HH };
  }

  function idwt2D(b, h, w) {
    const halfH = h >> 1, halfW = w >> 1;
    const tA = new Float32Array(h * halfW), tD = new Float32Array(h * halfW);
    for (let y = 0; y < halfH; y++) {
      for (let x = 0; x < halfW; x++) {
        const idx = y * halfW + x;
        const ll = b.LL[idx], lh = b.LH[idx];
        const hl = b.HL[idx], hh = b.HH[idx];
        tA[(y << 1) * halfW + x]       = ll + lh;
        tA[((y << 1) + 1) * halfW + x] = ll - lh;
        tD[(y << 1) * halfW + x]       = hl + hh;
        tD[((y << 1) + 1) * halfW + x] = hl - hh;
      }
    }
    const out = new Float32Array(h * w);
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < halfW; x++) {
        const a = tA[y * halfW + x], d = tD[y * halfW + x];
        out[y * w + (x << 1)]     = a + d;
        out[y * w + (x << 1) + 1] = a - d;
      }
    }
    return out;
  }

  function embedWatermark(gray, bits, h, w, alpha = 8) {
    const b = dwt2D(gray, h, w);
    const len = Math.min(bits.length, b.LH.length);
    for (let i = 0; i < len; i++) b.LH[i] += alpha * (bits[i] ? 1 : -1);
    return idwt2D(b, h, w);
  }

  // -- Button Logic --

  btnAdd.onclick = () => imgInput.click();
  imgInput.onchange = e => {
    const f = e.target.files[0]; if (!f) return;
    const img = new Image();
    img.onload = () => {
      origGray = imageToGray(img, origCan);
      imgW = origCan.width; imgH = origCan.height;
      origRGB = ctxO.getImageData(0, 0, imgW, imgH).data.slice();
      grayToCanvas(origGray, imgW, imgH, origCan);
      ctxW.clearRect(0, 0, wmCan.width, wmCan.height);
    };
    img.src = URL.createObjectURL(f);
  };

  btnSelWM.onclick = () => wmImgInput.click();
  wmImgInput.onchange = e => {
    const f = e.target.files[0]; if (!f) return;
    const img = new Image();
    img.onload = () => {
      const wmGray = imageToGray(img, wmCan);
      wmBits = Uint8Array.from(wmGray, v => (v > 127 ? 1 : 0));
      grayToCanvas(wmGray, wmCan.width, wmCan.height, wmCan);
    };
    img.src = URL.createObjectURL(f);
  };

  btnEmbed.onclick = () => {
    if (!origGray) return alert("Please select an image first");
    const txt = wmText.value.trim();
    if (txt && !wmBits) wmBits = textToBits(txt);
    if (!wmBits) return alert("Please input watermark (text or image)");
    embeddedGray = embedWatermark(origGray, wmBits, imgH, imgW);
    embedToColorCanvas(embeddedGray, imgW, imgH, origRGB, origCan);
  };

  btnDownload.onclick = () => {
    const link = document.createElement("a");
    link.download = "embedded.png";
    link.href = origCan.toDataURL("image/png");
    link.click();
  };

  btnRetrieve.onclick = () => {
    if (!origCan.width || !origCan.height) return alert("Load embedded image first");
    const gray = imageToGray(origCan, origCan);
    const b = dwt2D(gray, imgH, imgW);
    const extracted = b.LH;
    const min = Math.min(...extracted), max = Math.max(...extracted);
    const norm = extracted.map(v => 255 * (v - min) / (max - min));
    grayToCanvas(norm, imgW >> 1, imgH >> 1, wmCan);
  };
  </script>
</body>
</html>
